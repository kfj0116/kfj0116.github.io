<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="LeetCode,">










<meta name="description" content="Record the Tree topic algorithm problems.">
<meta name="keywords" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode - Tree">
<meta property="og:url" content="http://yoursite.com/2019/11/20/leetcode5/index.html">
<meta property="og:site_name" content="Fanjia Kong">
<meta property="og:description" content="Record the Tree topic algorithm problems.">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-01-28T09:07:32.230Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode - Tree">
<meta name="twitter:description" content="Record the Tree topic algorithm problems.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/20/leetcode5/">





  <title>LeetCode - Tree | Fanjia Kong</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fanjia Kong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Frontend Developer</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/20/leetcode5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fanjia Kong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fanjia Kong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode - Tree</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-20T16:44:29+02:00">
                2019-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Record the Tree topic algorithm problems.</p>
<a id="more"></a>

<h2 id="0094-Binary-Tree-Inorder-Traversal"><a href="#0094-Binary-Tree-Inorder-Traversal" class="headerlink" title="0094. Binary Tree Inorder Traversal"></a>0094. Binary Tree Inorder Traversal</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.<br>Example:<br>Input: [1,null,2,3]<br>Output: [1,3,2]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const inorderTraversal = (root, arr = []) =&gt; &#123;</span><br><span class="line">    if (root) &#123;</span><br><span class="line">        inorderTraversal(root.left, arr);</span><br><span class="line">        arr.push(root.val);</span><br><span class="line">        inorderTraversal(root.right, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 52 ms<br>Memory Usage: 33.9 MB</p>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const inorderTraversal = (root) =&gt; &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    const res = [];</span><br><span class="line">    while (root || stack.length) &#123;</span><br><span class="line">        if (root) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.push(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 48 ms<br>Memory Usage: 33.9 MB</p>
<h2 id="0098-Validate-Binary-Search-Tree"><a href="#0098-Validate-Binary-Search-Tree" class="headerlink" title="0098. Validate Binary Search Tree"></a>0098. Validate Binary Search Tree</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:<br>Input: [2,1,3]<br>Output: true<br>Example 2:<br>Input: [5,1,4,null,null,3,6]<br>Output: false<br>Explanation: The root node’s value is 5 but its right child’s value is 4.</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const isValidBST = (root) =&gt; &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function helper(root, min, max) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((min !== null &amp;&amp; root.val &lt;= min) || (max !== null &amp;&amp; root.val &gt;= max)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Continue to scan left and right</span><br><span class="line">        return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return helper(root, null, null);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 64 ms<br>Memory Usage: 37.6 MB</p>
<h2 id="0101-Symmetric-Tree"><a href="#0101-Symmetric-Tree" class="headerlink" title="0101. Symmetric Tree"></a>0101. Symmetric Tree</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<br>For example, this binary tree [1,2,2,3,4,4,3] is symmetric<br>But the following [1,2,2,null,3,null,3] is not</p>
<h3 id="solution-1-1"><a href="#solution-1-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Definition for a binary tree node.</span><br><span class="line">function TreeNode(val) &#123;</span><br><span class="line">  this.val = val;</span><br><span class="line">  this.left = this.right = null;</span><br><span class="line">&#125;</span><br><span class="line">@param &#123;TreeNode&#125; root</span><br><span class="line">@return &#123;boolean&#125;</span><br><span class="line">*/</span><br><span class="line">const isSymmetric = (root) =&gt; &#123;</span><br><span class="line">if (!root) &#123; // Sanity check</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // Check if tree s &amp; t are mirroring each other</span><br><span class="line">    function isMirror(s, t) &#123;</span><br><span class="line">        if (!s &amp;&amp; !t) &#123;</span><br><span class="line">            return true; // Both nodes are null, ok</span><br><span class="line">        &#125;</span><br><span class="line">        if (!s || !t || s.val !== t.val) &#123;</span><br><span class="line">            return false; // Found a mismatch</span><br><span class="line">        &#125;</span><br><span class="line">        // Compare the left subtree of `s` with the right subtree of `t`</span><br><span class="line">        // and the right subtree of `s` with the left subtree of `t`</span><br><span class="line">        return isMirror(s.left, t.right) &amp;&amp; isMirror(s.right, t.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isMirror(root.left, root.right);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time complexity is O(n), and space complexity is O(1)<br>Runtime: 64 ms<br>Memory Usage: 35.6 MB</p>
<h3 id="solution-2-1"><a href="#solution-2-1" class="headerlink" title="solution 2:"></a>solution 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const isSymmetric = (root) =&gt; &#123;</span><br><span class="line">if (!root) &#123; // Sanity check</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // Check if tree s &amp; t are mirroring each other</span><br><span class="line">    function isMirror(p, q) &#123;</span><br><span class="line">        // Create two stacks</span><br><span class="line">        var s1 = [p], s2 = [q];</span><br><span class="line"></span><br><span class="line">        // Perform preorder traversal</span><br><span class="line">        while (s1.length &gt; 0 || s2.length &gt; 0) &#123;</span><br><span class="line">            var n1 = s1.pop(), n2 = s2.pop();</span><br><span class="line"></span><br><span class="line">            // Two null nodes, let&apos;s continue</span><br><span class="line">            if (!n1 &amp;&amp; !n2) continue;</span><br><span class="line"></span><br><span class="line">            // Return false as long as there is a mismatch</span><br><span class="line">            if (!n1 || !n2 || n1.val !== n2.val) return false;</span><br><span class="line"></span><br><span class="line">            // Scan tree s from left to right</span><br><span class="line">            // and scan tree t from right to left</span><br><span class="line">            s1.push(n1.left); s1.push(n1.right);</span><br><span class="line">            s2.push(n2.right); s2.push(n2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isMirror(root.left, root.right);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time complexity is still O(n), and space complexity is the height of the tree.<br>Runtime: 64 ms<br>Memory Usage: 35.5 MB</p>
<h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution 3:"></a>solution 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const isSymmetric = (root) =&gt; &#123;</span><br><span class="line">if (!root) &#123; // Sanity check</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // Check if tree s &amp; t are mirroring each other</span><br><span class="line">    function isMirror(s, t) &#123;</span><br><span class="line">        let q1 = [s], q2 = [t];</span><br><span class="line"></span><br><span class="line">        // Perform breadth-first search</span><br><span class="line">        while (q1.length &gt; 0 || q2.length &gt; 0) &#123;</span><br><span class="line">            // Dequeue</span><br><span class="line">            let n1 = q1.shift(), n2 = q2.shift();</span><br><span class="line"></span><br><span class="line">            // Two null nodes, let&apos;s continue</span><br><span class="line">            if (!n1 &amp;&amp; !n2) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Return false as long as there is a mismatch</span><br><span class="line">            if (!n1 || !n2 || n1.val !== n2.val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Scan tree s from left to right</span><br><span class="line">            // and scan tree t from right to left</span><br><span class="line">            q1.push(n1.left); q1.push(n1.right);</span><br><span class="line">            q2.push(n2.right); q2.push(n2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isMirror(root.left, root.right);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time complexity is O(n) and space complexity is the width of the tree.<br>Runtime: 68 ms<br>Memory Usage: 35.6 MB</p>
<h2 id="0102-Binary-Tree-Level-Order-Traversal"><a href="#0102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="0102. Binary Tree Level Order Traversal"></a>0102. Binary Tree Level Order Traversal</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>return its level order traversal as:<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const levelOrder = (root) =&gt; &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    const stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    const result = [];</span><br><span class="line">    while (stack.length &gt; 0) &#123;</span><br><span class="line">        const size = stack.length;</span><br><span class="line">        const temp = [];</span><br><span class="line">        for (let i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            const node = stack.shift();</span><br><span class="line">            temp.push(node.val);</span><br><span class="line">            if (node.left) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 60 ms<br>Memory Usage: 35 MB</p>
<h2 id="0104-Maximum-Depth-of-Binary-Tree"><a href="#0104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="0104. Maximum Depth of Binary Tree"></a>0104. Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>Note: A leaf is a node with no children.<br>Example:<br>Given binary tree [3,9,20,null,null,15,7],<br>return its depth = 3.</p>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const maxDepth = (root) =&gt; &#123;</span><br><span class="line">if (root === null) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 52 ms<br>Memory Usage: 37.3 MB</p>
<h2 id="0105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#0105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="0105. Construct Binary Tree from Preorder and Inorder Traversal"></a>0105. Construct Binary Tree from Preorder and Inorder Traversal</h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:<br>[3,9,20,null,null,15,7]</p>
<h3 id="solution-1-2"><a href="#solution-1-2" class="headerlink" title="solution 1:"></a>solution 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const buildTree = (preorder, inorder) =&gt; &#123;</span><br><span class="line">    let p = 0, i = 0;</span><br><span class="line">    function build(stop) &#123;</span><br><span class="line">        if (inorder[i] !== stop) &#123;</span><br><span class="line">            let root = new TreeNode(preorder[p++])</span><br><span class="line">            root.left = build(root.val)</span><br><span class="line">            i++</span><br><span class="line">            root.right = build(stop)</span><br><span class="line">            return root</span><br><span class="line">        &#125;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    return build()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 80 ms<br>Memory Usage: 36.2 MB</p>
<h3 id="solution-2-2"><a href="#solution-2-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const buildTree = (preorder, inorder) =&gt; &#123;</span><br><span class="line">    function helper(p1, p2, i1, i2) &#123;</span><br><span class="line">        if (p1 &gt; p2 || i1 &gt; i2) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        let value = preorder[p1],           // get the root value</span><br><span class="line">            index = inorder.indexOf(value), // get inorder position</span><br><span class="line">            nLeft = index - i1,             // count nodes in left subtree</span><br><span class="line">            root  = new TreeNode(value);    // build the root node</span><br><span class="line"></span><br><span class="line">        // build the left and right subtrees recursively</span><br><span class="line">        root.left  = helper(p1 + 1, p1 + nLeft, i1, index - 1);</span><br><span class="line">        root.right = helper(p1 + nLeft + 1, p2, index + 1, i2);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return helper(0, preorder.length - 1, 0, inorder.length - 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 64 ms<br>Memory Usage: 36.3 MB</p>
<h2 id="0108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#0108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="0108. Convert Sorted Array to Binary Search Tree"></a>0108. Convert Sorted Array to Binary Search Tree</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br>Example:<br>Given the sorted array: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5]</p>
<h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const sortedArrayToBST = (nums) =&gt; &#123;</span><br><span class="line">    if(!nums.length) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    let mid = Math.floor((nums.length)/2);</span><br><span class="line">    let root = new TreeNode(nums[mid]);</span><br><span class="line">    root.left = sortedArrayToBST(nums.slice(0, mid));</span><br><span class="line">    root.right = sortedArrayToBST(nums.slice(mid+1));</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 72 ms<br>Memory Usage: 37.6 MB</p>
<h2 id="0114-Flatten-Binary-Tree-to-Linked-List"><a href="#0114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="0114. Flatten Binary Tree to Linked List"></a>0114. Flatten Binary Tree to Linked List</h2><p>Given a binary tree, flatten it to a linked list in-place.<br>For example, given the following tree:<br>[1,2,5,3,4,null,6]<br>The flattened tree should look like:<br>[1,null,2,null,3,null,4,null,5,null,6]</p>
<h3 id="solution-4"><a href="#solution-4" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const flatten = (root) =&gt; &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    let left = root.left;</span><br><span class="line">    let right = root.right;</span><br><span class="line">    flatten(left);</span><br><span class="line">    flatten(right);</span><br><span class="line">    root.left = null;</span><br><span class="line">    root.right = left;</span><br><span class="line">    let cur = root;</span><br><span class="line">    while (cur.right !== null) &#123;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.right = right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 60 ms<br>Memory Usage: 35.8 MB</p>
<h2 id="0226-Invert-Binary-Tree"><a href="#0226-Invert-Binary-Tree" class="headerlink" title="0226. Invert Binary Tree"></a>0226. Invert Binary Tree</h2><p>Example:<br>Input:<br>[4,2,7,1,3,6,9]<br>Output:<br>[4,7,2,9,6,3,1]</p>
<h3 id="solution-1-3"><a href="#solution-1-3" class="headerlink" title="solution 1:"></a>solution 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- Definition for a binary tree node.</span><br><span class="line">- function TreeNode(val) &#123;</span><br><span class="line">-     this.val = val;</span><br><span class="line">-     this.left = this.right = null;</span><br><span class="line">- &#125;</span><br><span class="line">  \*/</span><br><span class="line">  /\*\*</span><br><span class="line">- @param &#123;TreeNode&#125; root</span><br><span class="line">- @return &#123;TreeNode&#125;</span><br><span class="line">  \*/</span><br><span class="line">  // Recursive</span><br><span class="line">  const invertTree = (root) =&gt; &#123;</span><br><span class="line">  if (root) &#123;</span><br><span class="line">  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];</span><br><span class="line">  &#125;</span><br><span class="line">  return root;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 60 ms<br>Memory Usage: 33.9 MB</p>
<h3 id="solution-2-3"><a href="#solution-2-3" class="headerlink" title="solution 2:"></a>solution 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// BFS</span><br><span class="line">const invertTree = (root) =&gt; &#123;</span><br><span class="line">if (!root) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">let queue = [root];</span><br><span class="line"></span><br><span class="line">    while (queue.length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        const node = queue.shift();</span><br><span class="line"></span><br><span class="line">        [node.left, node.right] = [node.right, node.left];</span><br><span class="line"></span><br><span class="line">        if (node.left) &#123;</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) &#123;</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 56 ms<br>Memory Usage: 33.8 MB</p>
<h3 id="solution-3-1"><a href="#solution-3-1" class="headerlink" title="solution 3:"></a>solution 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// DFS</span><br><span class="line">const invertTree = (root) =&gt; &#123;</span><br><span class="line">if (!root) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">let stack = [root];</span><br><span class="line"></span><br><span class="line">    while (stack.length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        const node = stack.pop();</span><br><span class="line"></span><br><span class="line">        [node.left, node.right] = [node.right, node.left];</span><br><span class="line"></span><br><span class="line">        if (node.left) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 56 ms<br>Memory Usage: 33.8 MB</p>
<h2 id="0236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#0236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="0236. Lowest Common Ancestor of a Binary Tree"></a>0236. Lowest Common Ancestor of a Binary Tree</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]<br>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.<br>Example 2:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<h3 id="solution-1-4"><a href="#solution-1-4" class="headerlink" title="solution 1:"></a>solution 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const lowestCommonAncestor = (root, p, q) =&gt; &#123;</span><br><span class="line">  if (!root || root === p || root === q) &#123;</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line">  let resL = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  let resR = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">  return (resL &amp;&amp; resR) ? root : (resL || resR);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 88 ms<br>Memory Usage: 41.5 MB</p>
<h3 id="solution-2-4"><a href="#solution-2-4" class="headerlink" title="solution 2:"></a>solution 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const lowestCommonAncestor = (root, p, q) =&gt; &#123;</span><br><span class="line">    if (!root || root === p || root === q) return root</span><br><span class="line">    const left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    const right = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    if (!left) &#123;</span><br><span class="line">        return right;  // p and q are in the right subtree</span><br><span class="line">    &#125;</span><br><span class="line">    if (!right) &#123;</span><br><span class="line">        return left;  // p and q are in the left subtree</span><br><span class="line">    &#125;</span><br><span class="line">    return root;     // p is in one side and q is in the other</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 64 ms<br>Memory Usage: 41.6 MB</p>
<h2 id="0337-House-Robber-III"><a href="#0337-House-Robber-III" class="headerlink" title="0337. House Robber III"></a>0337. House Robber III</h2><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.<br>Example 1:<br>Input: [3,2,3,null,3,null,1]<br>Output: 7<br>Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:<br>Input: [3,4,5,1,3,null,1]<br>Output: 9<br>Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<h3 id="solution-5"><a href="#solution-5" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const rob = (root) =&gt; &#123;</span><br><span class="line">  const &#123; current, next &#125; = traverse(root);</span><br><span class="line">  function traverse(root) &#123;</span><br><span class="line">      if (!root) &#123;</span><br><span class="line">        return &#123; current: 0, next: 0 &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const left = traverse(root.left);</span><br><span class="line">      const right = traverse(root.right);</span><br><span class="line">      const current = root.val + left.next + right.next;</span><br><span class="line">      const next = Math.max(left.current, left.next) + Math.max(right.current, right.next);</span><br><span class="line"></span><br><span class="line">      return &#123; current, next &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(current, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 68 ms<br>Memory Usage: 38.2 MB</p>
<h2 id="0437-Path-Sum-III"><a href="#0437-Path-Sum-III" class="headerlink" title="0437. Path Sum III"></a>0437. Path Sum III</h2><p>You are given a binary tree in which each node contains an integer value.<br>Find the number of paths that sum to a given value.<br>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).<br>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.<br>Example:<br>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8<br>Return 3. The paths that sum to 8 are:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<h3 id="solution-6"><a href="#solution-6" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const pathSum = (root, sum, presums = &#123; &apos;0&apos;: 1 &#125;, prev = 0) =&gt; &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let curr = prev + root.val;</span><br><span class="line">    presums[curr] = (presums[curr] || 0) + 1;</span><br><span class="line">    let res = (presums[curr - sum] || 0) - !sum;</span><br><span class="line">    res += pathSum(root.left, sum, presums, curr) + pathSum(root.right, sum, presums, curr);</span><br><span class="line">    presums[curr]--;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 68 ms<br>Memory Usage: 38.4 MB</p>
<h2 id="0543-Diameter-of-Binary-Tree"><a href="#0543-Diameter-of-Binary-Tree" class="headerlink" title="0543. Diameter of Binary Tree"></a>0543. Diameter of Binary Tree</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.<br>Example:<br>Given a binary tree [1,2,3,4,5]<br>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].<br>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<h3 id="solution-7"><a href="#solution-7" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const diameterOfBinaryTree = (root) =&gt; &#123;</span><br><span class="line">    let diameter = 0;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line"></span><br><span class="line">    return diameter;</span><br><span class="line"></span><br><span class="line">    function dfs(node, level) &#123;</span><br><span class="line">        if (!node) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const left = dfs(node.left);</span><br><span class="line">        const right = dfs(node.right);</span><br><span class="line"></span><br><span class="line">        // update diameter at every node</span><br><span class="line">        diameter = Math.max(diameter, left + right);</span><br><span class="line"></span><br><span class="line">        // update the largest number of edge so far</span><br><span class="line">        return 1 + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 68 ms<br>Memory Usage: 37.1 MB</p>
<h2 id="0617-Merge-Two-Binary-Trees"><a href="#0617-Merge-Two-Binary-Trees" class="headerlink" title="0617. Merge Two Binary Trees"></a>0617. Merge Two Binary Trees</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.<br>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.<br>Example 1:<br>Input<br>[1,3,2,5][2,1,3,null,4,null,7]<br>Output<br>[3,4,5,5,4,null,7]</p>
<h3 id="solution-8"><a href="#solution-8" class="headerlink" title="solution:"></a>solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const mergeTrees = (t1, t2) =&gt; &#123;</span><br><span class="line">    if (!t1 &amp;&amp; !t2) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!t1 || !t2) &#123;</span><br><span class="line">        return t1 || t2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var root = new TreeNode(t1.val + t2.val);</span><br><span class="line"></span><br><span class="line">    root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Runtime: 92 ms<br>Memory Usage: 40.6 MB</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i> LeetCode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/19/leetcode4/" rel="next" title="LeetCode - String">
                <i class="fa fa-chevron-left"></i> LeetCode - String
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/21/leetcode6/" rel="prev" title="LeetCode - Linked List">
                LeetCode - Linked List <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fanjia Kong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:kfj0116@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0094-Binary-Tree-Inorder-Traversal"><span class="nav-number">1.</span> <span class="nav-text">0094. Binary Tree Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1"><span class="nav-number">1.1.</span> <span class="nav-text">solution 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2"><span class="nav-number">1.2.</span> <span class="nav-text">solution 2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0098-Validate-Binary-Search-Tree"><span class="nav-number">2.</span> <span class="nav-text">0098. Validate Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution"><span class="nav-number">2.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0101-Symmetric-Tree"><span class="nav-number">3.</span> <span class="nav-text">0101. Symmetric Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1-1"><span class="nav-number">3.1.</span> <span class="nav-text">solution 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2-1"><span class="nav-number">3.2.</span> <span class="nav-text">solution 2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-3"><span class="nav-number">3.3.</span> <span class="nav-text">solution 3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0102-Binary-Tree-Level-Order-Traversal"><span class="nav-number">4.</span> <span class="nav-text">0102. Binary Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1"><span class="nav-number">4.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">0104. Maximum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2"><span class="nav-number">5.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-number">6.</span> <span class="nav-text">0105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1-2"><span class="nav-number">6.1.</span> <span class="nav-text">solution 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2-2"><span class="nav-number">6.2.</span> <span class="nav-text">solution 2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-number">7.</span> <span class="nav-text">0108. Convert Sorted Array to Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-3"><span class="nav-number">7.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0114-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">8.</span> <span class="nav-text">0114. Flatten Binary Tree to Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-4"><span class="nav-number">8.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0226-Invert-Binary-Tree"><span class="nav-number">9.</span> <span class="nav-text">0226. Invert Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1-3"><span class="nav-number">9.1.</span> <span class="nav-text">solution 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2-3"><span class="nav-number">9.2.</span> <span class="nav-text">solution 2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-3-1"><span class="nav-number">9.3.</span> <span class="nav-text">solution 3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">10.</span> <span class="nav-text">0236. Lowest Common Ancestor of a Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1-4"><span class="nav-number">10.1.</span> <span class="nav-text">solution 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2-4"><span class="nav-number">10.2.</span> <span class="nav-text">solution 2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0337-House-Robber-III"><span class="nav-number">11.</span> <span class="nav-text">0337. House Robber III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-5"><span class="nav-number">11.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0437-Path-Sum-III"><span class="nav-number">12.</span> <span class="nav-text">0437. Path Sum III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-6"><span class="nav-number">12.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0543-Diameter-of-Binary-Tree"><span class="nav-number">13.</span> <span class="nav-text">0543. Diameter of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-7"><span class="nav-number">13.1.</span> <span class="nav-text">solution:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0617-Merge-Two-Binary-Trees"><span class="nav-number">14.</span> <span class="nav-text">0617. Merge Two Binary Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-8"><span class="nav-number">14.1.</span> <span class="nav-text">solution:</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fanjia Kong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
